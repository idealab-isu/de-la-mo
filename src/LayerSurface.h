#ifndef LAYERSURFACE_H
#define LAYERSURFACE_H

#include "APIConfig.h"

// Export file is generated by CMake's GenerateExportHeader module
#include "modelbuilder_export.h"


// Forward declarations
class LayerBody;

// Defines the structure of the surfaces
class MODELBUILDER_EXPORT LayerSurface
{
public:

	/**
	 * \brief Default constructor.
	 */
	LayerSurface();
	
	/**
	 * \brief Copy operator.
	 */
	LayerSurface(const LayerSurface& rhs);
	
	/**
	 * \brief Default destructor.
	 */
	~LayerSurface();

	/**
	 * \brief Copy assignment operator.
	 */
	LayerSurface& operator=(const LayerSurface& rhs);

	/**
	 * \brief Copies the layer surface to lhs.
	 * \param lhs new object
	 */
	void copy(LayerSurface& lhs);

	/**
	 * \brief Gets surface ID.
	 * \return surface ID
	 */
	int id();

	/**
	 * \brief Sets surface ID.
	 * \param[in] idnum new surface ID
	 */
	void id(int idnum);

	/**
	 * \brief Gets reference point.
	 * \return reference point
	 */
	delamo::TPoint3<double> point_coords();
	
	/**
	 * \brief Gets reference normal.
	 * \return reference normal
	 */
	delamo::TPoint3<double> normal_coords();
	
	/**
	 * \brief Gets the face as defined by the solid modeling kernel.
	 * \return face object
	 */
	DLM_FACEP face();

	/**
	 * \brief Sets the face as defined by the solid modeling kernel.
	 * \param[in] face face object
	 */
	void face(DLM_FACEP face);

	/**
	 * \brief Gets the reference point as defined the solid modeling kernel.
	 * \return point object
	 */
	DLM_POSITION point();

	/**
	 * \brief Sets the reference point as defined by the solid modeling kernel.
	 * \param[in] point point object
	 */
	void point(DLM_POSITION point);

	/**
	 * \brief Gets the reference normal as defined by the solid modeling kernel.
	 * \return vector object
	 */
	DLM_UNITVECTOR normal();

	/**
	 * \brief Sets the reference normal as defined by the solid modeling kernel.
	 * \param[in] normal vector object
	 */
	void normal(DLM_UNITVECTOR normal);

	/**
	 * \brief Gets the angle between the LayerSurface and a vector on the OFFSET direction.
	 * \param value angle
	 */
	void angle(double value);

	/**
	 * \brief Gets the angle between the LayerSurface and a vector on the OFFSET direction.
	 * \return angle
	 */
	double angle();

	/**
	 * \brief Sets the direction of the LayerSurface
	 * \param[in] stype new direction
	 */
	void direction(Direction stype);

	/**
	 * \brief Gets the direction of the LayerSurface
	 * \return direction
	 */
	Direction direction();

	/**
	 * \brief Sets delamination type.
	 * \param[in] dtype new delamination type
	 */
	void delam_type(DelaminationType dtype);

	/**
	 * \brief Gets delamination type.
	 * \return delamination type
	 */
	DelaminationType delam_type();

	/**
	 * \brief Sets the initial surface flag.
	 * \param[in] flag defines whether this surface is generated by create_layer or not
	 */
	void initial_surface(bool flag = true);
	
	/**
	 * \brief Checks whether this surface is generated during the create_layer() stage.
	 * \return if generated by create_layer() true, otherwise false
	 */
	bool is_initial_surface();


	/**
	 * \brief Sets the owner of the LayerSurface object.
	 * \param[in] owner new owner as a pointer to a LayerBody object
	 */
	void owner(LayerBody* owner);

	/**
	 * \brief Gets ownerof the LayerSurface object.
	 * \return owner as a pointer to a LayerBody object
	 */
	LayerBody* owner();

	/**
	 * \brief Sets the surface pair.
	 * \param[in] pair surface pair as a pointer to a LayerSurface object
	 */
	void pair(LayerSurface* pair);

	/**
	 * \brief Gets the surface pair.
	 * \return the surface pair as a pointer to a LayerSurface object
	 */
	LayerSurface* pair();

	/**
	 * \brief Clears surface pairs.
	 * 
	 * Please note that this function does not delete the paired LayerSurface objects, it only sets the pair variable to nullptr.
	 */
	void pair_clear();

	/**
	 * \brief Sets "generated from stiffener" flag
	 * \param val flag value
	 */
	void stiffener_gen(bool val);

	/**
	 * \brief Returns "generated from stiffener" flag
	 * \return if this surface is generated by stiffener imprinting then returns TRUE, otherwise FALSE
	 */
	bool is_stiffener_gen();

	/**
	 * \brief Sets "stiffened paired" flag
	 * \param val flag value
	 */
	void stiffener_paired(bool val);

	/**
	 * \brief Returns "stiffener paired" flag
	 * \return if this surface is paired with a stiffener once in its lifetime then returns TRUE, otherwise FALSE
	 */
	bool is_stiffener_paired();

	/**
	 * \brief Allows tracking surface origins
	 * \param ls LayerSurface from which this LayerSurface is generated
	 */
	void created_from(LayerSurface* ls);

	/**
	 * \brief Allows tracking surface origins
	 * \param ls LayerSurface from which this LayerSurface is generated
	 */
	void created_from(LayerSurface& ls);

	/**
	 * \brief Returns the origin surface from which this surface is generated
	 * \return origin LayerSurface
	 */
	LayerSurface* created_from();

private:
	int _mId; /**< ID of the LayerSurface */
	DLM_FACEP _mFace; /**< Stores the CAD object representation of the LayerSurface */
	DLM_POSITION _mPoint; /**< Stores the CAD representation of a point resides on this LayerSurface */
	DLM_UNITVECTOR _mNormal; /**< Stores the CAD representation of a unit vector normal to this LayerSurface at the point, _mPoint */
	double _mAngle; /**< Angle between the reference normal and the surface normal */
	bool _bInitialSurface; /**< Flag to check whether this is the first surface or not */
	Direction _eSurfDir; /**< LayerSurface direction */
	LayerBody* _pOwner; /**< Owner of the LayerSurface */
	DelaminationType _eDelaminationType; /**< Stores what kind of delamination that this LayerSurface has */
	LayerSurface* _pSurfPair; /**< Pair of the LayerSurface set after adjacent_layers() */
	bool _bStiffenerGenerated; /**< Stores "generated from stiffener" information */
	bool _bStiffenerPaired; /**< Stores "stiffener paired" information */
	LayerSurface* _pCreatedFrom; /**< Stores origin surface for tracking */

	void init_vars();
	void delete_vars();
	void copy_vars(const LayerSurface& rhs, LayerSurface& lhs);
};

#endif // !LAYERSURFACE_H
